//This class was generated by ME3Explorer
//Author: Warranty Voider
//URL: http://sourceforge.net/projects/me3explorer/
//URL: http://me3explorer.freeforums.org/
//URL: http://www.facebook.com/pages/Creating-new-end-for-Mass-Effect-3/145902408865659
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using ME3Explorer.Unreal;
using Microsoft.DirectX;
using Microsoft.DirectX.Direct3D;
using KFreonLib.Debugging;

namespace ME3Explorer.Unreal.Classes
{
    public class AnimSet
    {
        #region Unreal Props

        //Name Properties

        public int PreviewSkelMeshName;
        //Object Properties

        public int m_pBioAnimSetData;
        //Array Properties

        public List<int> Sequences;

        #endregion

        public int MyIndex;
        public PCCObject pcc;
        public byte[] data;
        public List<PropertyReader.Property> Props;
        public BioAnimSetData SetData;

        public AnimSet(PCCObject Pcc, int Index)
        {
            pcc = Pcc;
            MyIndex = Index;
            if (pcc.isExport(Index))
                data = pcc.Exports[Index].Data;
            Props = PropertyReader.getPropList(pcc, data);
            BitConverter.IsLittleEndian = true;
            Sequences = new List<int>();
            foreach (PropertyReader.Property p in Props)
                switch (pcc.getNameEntry(p.Name))
                {

                    case "PreviewSkelMeshName":
                        PreviewSkelMeshName = p.Value.IntValue;
                        break;
                    case "m_pBioAnimSetData":
                        m_pBioAnimSetData = p.Value.IntValue;
                        if (pcc.isExport(m_pBioAnimSetData - 1) && pcc.Exports[m_pBioAnimSetData - 1].ClassName == "BioAnimSetData")
                            SetData = new BioAnimSetData(pcc, m_pBioAnimSetData - 1);
                        break;
                    case "Sequences":
                        ReadSequences(p.raw);
                        break;
                }
        }

        public void ReadSequences(byte[] raw)
        {
            int count = GetArrayCount(raw);
            byte[] buff = GetArrayContent(raw);
            for (int i = 0; i < count; i++)
                Sequences.Add(BitConverter.ToInt32(buff, i * 4) - 1);
        }

        public int GetArrayCount(byte[] raw)
        {
            return BitConverter.ToInt32(raw, 24);
        }

        public byte[] GetArrayContent(byte[] raw)
        {
            byte[] buff = new byte[raw.Length - 28];
            for (int i = 0; i < raw.Length - 28; i++)
                buff[i] = raw[i + 28];
            return buff;
        }

        public TreeNode ToTree()
        {
            TreeNode res = new TreeNode("AnimSet : " + pcc.Exports[MyIndex].ObjectName + "(#" + MyIndex + ")");
            res.Nodes.Add("PreviewSkelMeshName : " + pcc.getNameEntry(PreviewSkelMeshName));
            res.Nodes.Add("m_pBioAnimSetData : " + m_pBioAnimSetData);
            if (SetData != null)
                res.Nodes.Add(SetData.ToTree());
            res.Nodes.Add(SequencesToTree());
            return res;
        }

        public TreeNode SequencesToTree()
        {
            TreeNode res = new TreeNode("Sequences");
            foreach (int idx in Sequences)
            {
                if (pcc.isExport(idx) && pcc.Exports[idx].ClassName == "AnimSequence")
                {
                    AnimSequence ans = new AnimSequence(pcc, idx);
                    res.Nodes.Add(ans.ToTree());
                }
                else                    
                    res.Nodes.Add(idx.ToString());
            }
            return res;
        }

        public void ExportToPSA(string path)
        {
            if (SetData == null)
                return;
            PSAFile psa = new PSAFile();
            PSAFile.PSAData d = psa.data;
            d.Bones = new List<PSAFile.PSABone>();                  //Export Bones
            int count = 0;
            foreach (string s in SetData.TrackBoneNames)
            {
                PSAFile.PSABone b = new PSAFile.PSABone();
                b.name = s;
                if (count++ == 0)
                    b.parent = -1;
                d.Bones.Add(b);
            }
            d.Infos = new List<PSAFile.PSAAnimInfo>();              //Export Sequences
            d.Keys = new List<PSAFile.PSAAnimKeys>();
            int currframe = 0;
            for (int i = 0; i < Sequences.Count - 1; i++)
            {
                int idx = Sequences[i];
                int idxn = Sequences[i + 1];
                AnimSequence seq = new AnimSequence(pcc, idx);
                AnimSequence seqn = new AnimSequence(pcc, idxn);
                PSAFile.PSAAnimInfo inf = new PSAFile.PSAAnimInfo();
                inf.AnimRate = 30;
                inf.TotalBones = d.Bones.Count;
                inf.FirstRawFrame = currframe;
                inf.TrackTime = inf.NumRawFrames = seq.NumFrames;
                inf.KeyQuotum = inf.NumRawFrames * inf.TotalBones;
                inf.name = pcc.getNameEntry(seq.SequenceName);
                inf.group = "None";
                d.Infos.Add(inf);
                for (int j = 0; j < inf.NumRawFrames; j++)
                    for (int k = 0; k < inf.TotalBones; k++)
                    {
                        Vector3 fromV = seq.CompressedTrackOffsets[k].Trans;
                        Vector3 toV = seqn.CompressedTrackOffsets[k].Trans;
                        Vector4 srotQ = seq.CompressedTrackOffsets[k].Rot;
                        Vector4 erotQ = seqn.CompressedTrackOffsets[k].Rot;
                        Quaternion q1 = Vec4ToQ(srotQ);
                        Quaternion q2 = Vec4ToQ(erotQ);
                        float t = (float)j / (float)(inf.NumRawFrames - 1);
                        Vector3 currV = Vector3.Lerp(fromV, toV, t);
                        Quaternion qc = Quaternion.Slerp(q1, q2, t);
                        PSAFile.PSAAnimKeys key = new PSAFile.PSAAnimKeys();
                        key.location = new PSAFile.PSAPoint(currV);
                        key.rotation = new PSAFile.PSAQuad(QToVec4(qc));
                        key.time = 1;
                        d.Keys.Add(key);
                    }
                currframe += seq.NumFrames;
            }
            AnimSequence s1 = new AnimSequence(pcc, Sequences[Sequences.Count-1]);
            AnimSequence s2;
            if (s1.bNoLoopingInterpolation)
                s2 = new AnimSequence(pcc, Sequences[Sequences.Count - 1]);
            else
                s2 = new AnimSequence(pcc, Sequences[0]);
            PSAFile.PSAAnimInfo inf2 = new PSAFile.PSAAnimInfo();
            inf2.AnimRate = 30;
            inf2.TotalBones = d.Bones.Count;
            inf2.FirstRawFrame = currframe;
            inf2.TrackTime = inf2.NumRawFrames = s1.NumFrames;
            inf2.KeyQuotum = inf2.NumRawFrames * inf2.TotalBones;
            inf2.name = pcc.getNameEntry(s1.SequenceName);
            inf2.group = "None";
            d.Infos.Add(inf2);
            for (int j = 0; j < inf2.NumRawFrames; j++)
                for (int k = 0; k < inf2.TotalBones; k++)
                {
                    Vector3 fromV = s1.CompressedTrackOffsets[k].Trans;
                    Vector3 toV = s2.CompressedTrackOffsets[k].Trans;
                    Vector4 srotQ = s1.CompressedTrackOffsets[k].Rot;
                    Vector4 erotQ = s2.CompressedTrackOffsets[k].Rot;
                    Quaternion q1 = Vec4ToQ(srotQ);
                    Quaternion q2 = Vec4ToQ(erotQ);
                    float t = (float)j / (float)(inf2.NumRawFrames - 1);
                    Vector3 currV = Vector3.Lerp(fromV, toV, t);
                    Quaternion qc = Quaternion.Slerp(q1, q2, t);
                    PSAFile.PSAAnimKeys key = new PSAFile.PSAAnimKeys();
                    key.location = new PSAFile.PSAPoint(currV);
                    key.rotation = new PSAFile.PSAQuad(QToVec4(qc));
                    key.time = 1;
                    d.Keys.Add(key);
                }
            psa.data = d;
            psa.ExportPSA(path);
        }

        public bool ImportFromPSA(string path)
        {
            PSAFile psa = new PSAFile();
            psa.ImportPSA(path);
            PSAFile.PSAData d = psa.data;
            DebugOutput.PrintLn("Checking data...");
            if (d.Bones.Count != SetData.TrackBoneNames.Count)
            {
                MessageBox.Show("Cant import: different count of bones");
                return false;
            }
            for (int i = 0; i < SetData.TrackBoneNames.Count; i++)
                if (d.Bones[i].name != SetData.TrackBoneNames[i])
                {
                    MessageBox.Show("Cant import: couldnt match all bones");
                    return false;
                }
            if (d.Infos.Count != Sequences.Count)
            {
                MessageBox.Show("Cant import: different count of sequences");
                return false;
            }
            for (int i = 0; i < Sequences.Count; i++)
            {
                AnimSequence ans = new AnimSequence(pcc, Sequences[i]);
                if (d.Infos[i].name != pcc.getNameEntry(ans.SequenceName))
                {
                    MessageBox.Show("Cant import: couldnt match all sequences");
                    return false;
                }
            }
            int pos = 0;
            for (int i = 0; i < Sequences.Count; i++)
            {
                DebugOutput.PrintLn("Importing into AnimSequence #" + Sequences[i] + " ...");
                AnimSequence ans = new AnimSequence(pcc, Sequences[i]);
                PSAFile.PSAAnimInfo inf = d.Infos[i];
                List<Vector3> loc = new List<Vector3>();
                List<Vector4> rot = new List<Vector4>();
                for (int j = 0; j < inf.TotalBones; j++)
                {
                    PSAFile.PSAAnimKeys key = d.Keys[pos + j];
                    loc.Add(key.location.ToVector3());
                    rot.Add(key.rotation.ToVector4());
                }
                ans.ImportKeys(loc.ToArray(), rot.ToArray(), inf.NumRawFrames);
                ans.SaveChanges();
                pos += inf.KeyQuotum;
            }
            pcc.saveToFile();
            return true;
        }

        public Quaternion Vec4ToQ(Vector4 v)
        {
            return new Quaternion(v.X, v.Y, v.Z, v.W);
        }

        public Vector4 QToVec4(Quaternion q)
        {
            return new Vector4(q.X, q.Y, q.Z, q.W);
        }
    }
}