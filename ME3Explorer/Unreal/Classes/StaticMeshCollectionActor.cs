//This class was generated by ME3Explorer
//Author: Warranty Voider
//URL: http://sourceforge.net/projects/me3explorer/
//URL: http://me3explorer.freeforums.org/
//URL: http://www.facebook.com/pages/Creating-new-end-for-Mass-Effect-3/145902408865659
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using ME3Explorer.Unreal;
using Microsoft.DirectX;
using Microsoft.DirectX.Direct3D;
using lib3ds.Net;
using KFreonLib.Debugging;

namespace ME3Explorer.Unreal.Classes
{
    public class StaticMeshCollectionActor
    {
        #region Unreal Props

        //Bool Properties

        public bool bCanStepUpOn = false;
        //Name Properties

        public int Tag;
        //Float Properties

        public float CreationTime;

        #endregion

        public int MyIndex;
        public PCCObject pcc;
        public byte[] data;
        public List<PropertyReader.Property> Props;
        public List<int> Entries;
        public List<Matrix> Matrices;
        public List<StaticMeshComponent> STMC;
        public bool isEdited = false;

        public StaticMeshCollectionActor(PCCObject Pcc, int Index)
        {
            pcc = Pcc;
            MyIndex = Index;
            if (pcc.isExport(Index))
                data = pcc.Exports[Index].Data;
            Props = PropertyReader.getPropList(pcc, data);
            BitConverter.IsLittleEndian = true;
            foreach (PropertyReader.Property p in Props)
                switch (pcc.getNameEntry(p.Name))
                {

                    case "bCanStepUpOn":
                        if (p.raw[p.raw.Length - 1] == 1)
                            bCanStepUpOn = true;
                        break;
                    case "Tag":
                        Tag = p.Value.IntValue;
                        break;
                    case "CreationTime":
                        CreationTime = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                }
            ReadObjects();
            ReadMatrices();
        }

        public void ReadObjects()
        {            
            int entry = -1;
            for (int i = 0; i < Props.Count; i++)
                if (pcc.getNameEntry(Props[i].Name) == "StaticMeshComponents")
                    entry = i;
            if (entry == -1)
                return;
            int count = BitConverter.ToInt32(Props[entry].raw, 24);
            DebugOutput.PrintLn("#" + MyIndex + " StaticMeshCollectionActor : reading " + count +" objects...");
            Entries = new List<int>();
            for (int i = 0; i < count; i++)
                Entries.Add(BitConverter.ToInt32(Props[entry].raw, i * 4 + 28) - 1);
            STMC = new List<StaticMeshComponent>();
            foreach (int idx in Entries)
            {
                if (pcc.isExport(idx) && pcc.Exports[idx].ClassName == "StaticMeshComponent")
                    STMC.Add(new StaticMeshComponent(pcc, idx));
                else
                    STMC.Add(null);
                DebugOutput.Print(".",false);
            }
            DebugOutput.PrintLn("");
        }

        public void ReadMatrices()
        {
            int pos = Props[Props.Count - 1].offend;
            Matrices = new List<Matrix>();
            for (int i = 0; i < Entries.Count; i++)
            {
                Matrix m = new Matrix();
                float[,] buff = new float[4, 4];
                for (int y = 0; y < 4; y++)
                    for (int x = 0; x < 4; x++)
                    {
                        buff[x, y] = BitConverter.ToSingle(data, pos);
                        pos += 4;
                    }
                m.M11 = buff[0, 0];
                m.M12 = buff[1, 0];
                m.M13 = buff[2, 0];
                m.M14 = buff[3, 0];

                m.M21 = buff[0, 1];
                m.M22 = buff[1, 1];
                m.M23 = buff[2, 1];
                m.M24 = buff[3, 1];

                m.M31 = buff[0, 2];
                m.M32 = buff[1, 2];
                m.M33 = buff[2, 2];
                m.M34 = buff[3, 2];

                m.M41 = buff[0, 3];
                m.M42 = buff[1, 3];
                m.M43 = buff[2, 3];
                m.M44 = buff[3, 3];
                Matrices.Add(m);
            }
        }

        public void Render(Device device)
        {
            for (int i = 0; i < STMC.Count; i++)
                if(STMC[i]!=null)
                    STMC[i].Render(device, Matrices[i]);
        }

        public void ProcessTreeClick(int[] path, bool AutoFocus)
        {
            if (path.Length == 3) //select all childs
            {
                foreach (StaticMeshComponent stmc in STMC)
                    stmc.SetSelection(true);
            }
            else//select specific child
            {
                int idx = path[3] - 3;//get selected child
                if (idx >= 0 && idx < Entries.Count && pcc.isExport(Entries[idx]) && pcc.Exports[Entries[idx]].ClassName == "StaticMeshComponent")
                    for (int i = 0; i < STMC.Count; i++)
                        if (STMC[i].MyIndex == Entries[idx])
                        {
                            STMC[i].SetSelection(true);
                            if(AutoFocus)
                                STMC[i].Focus(Matrices[i]);//focus camera
                        }
            }
        }

        public float Process3DClick(Vector3 org, Vector3 dir, out int Idx)
        {
            float dist = -1f;
            Idx = -1;
            for (int i = 0; i < STMC.Count; i++)
                if (STMC[i] != null)
                {
                    float d = STMC[i].Process3DClick(org, dir, Matrices[i]);
                    if ((d < dist && d > 0) || (dist == -1 && d > 0))
                    {
                        dist = d;
                        Idx = i;
                    }
                }
            return dist;
        }

        public void ApplyTransform(Matrix m)
        {
            for (int i = 0; i < STMC.Count; i++)
                if (STMC[i] != null && STMC[i].GetSelection() == true)
                {
                    isEdited = true;
                    Matrices[i] *= m;
                }
        }

        public void ApplyRotation(Vector3 v)
        {
            for (int i = 0; i < STMC.Count; i++)
                if (STMC[i] != null && STMC[i].GetSelection() == true)
                {
                    isEdited = true;
                    Matrix m = Matrices[i];
                    Vector3 v2 = new Vector3(m.M41, m.M42, m.M43);
                    float f = 3.1415f / 180f;
                    m.M41 = 0;
                    m.M42 = 0;
                    m.M43 = 0;
                    m *= Matrix.RotationYawPitchRoll(-v.X * f, -v.Y * f, v.Z * f);
                    m.M41 = v2.X;
                    m.M42 = v2.Y;
                    m.M43 = v2.Z;
                    Matrices[i] = m;
                }
        }

        public void SaveChanges()
        {
            if (isEdited)
            {
                int pos = Props[Props.Count - 1].offend;
                for (int i = 0; i < Matrices.Count; i++)
                {
                    byte[] buff = MatrixToBuff(Matrices[i]);
                    for (int j = 0; j < 64; j++)
                        data[pos + j] = buff[j];
                    pos += 64;
                }
                pcc.Exports[MyIndex].Data = data;
            }
        }

        public void CreateModJobs()
        {
            if (isEdited)
            {
                int pos = Props[Props.Count - 1].offend;
                for (int i = 0; i < Matrices.Count; i++)
                {
                    byte[] buff = MatrixToBuff(Matrices[i]);
                    for (int j = 0; j < 64; j++)
                        data[pos + j] = buff[j];
                    pos += 64;
                }
                KFreonLib.Scripting.ModMaker.ModJob mj = new KFreonLib.Scripting.ModMaker.ModJob();
                string currfile = Path.GetFileName(pcc.pccFileName);
                mj.data = data;
                mj.Name = "Binary Replacement for file \"" + currfile + "\" in Object #" + MyIndex + " with " + data.Length + " bytes of data";
                string loc = Path.GetDirectoryName(Application.ExecutablePath);
                string template = System.IO.File.ReadAllText(loc + "\\exec\\JobTemplate_Binary2.txt");
                template = template.Replace("**m1**", MyIndex.ToString());
                template = template.Replace("**m2**", currfile);
                mj.Script = template;
                KFreonLib.Scripting.ModMaker.JobList.Add(mj);
                DebugOutput.PrintLn("Created Mod job : " + mj.Name);
            }
        }

        public void SetSelection(bool Selected)
        {
            foreach (StaticMeshComponent stmc in STMC)
                stmc.SetSelection(Selected);
        }

        public void SetSelection(bool Selected, int Idx)
        {
            STMC[Idx].SetSelection(Selected);
        }

        public void Export3DS(Lib3dsFile f)
        {
            for (int i = 0; i < STMC.Count; i++)
                if (STMC[i] != null)
                {
                    DebugOutput.PrintLn((i + 1) + "/" + STMC.Count + " Exported " + pcc.Exports[MyIndex].ObjectName + " #" + MyIndex, false);
                    STMC[i].Export3DS(f, Matrices[i]);
                }
            DebugOutput.PrintLn("STMCA done.");
        }

        public TreeNode ToTree()
        {
            TreeNode res = new TreeNode("#" + MyIndex + " : " + pcc.Exports[MyIndex].ObjectName);
            res.Nodes.Add("bCanStepUpOn : " + bCanStepUpOn);
            res.Nodes.Add("Tag : " + pcc.getNameEntry(Tag));
            res.Nodes.Add("CreationTime : " + CreationTime);
            foreach (StaticMeshComponent c in STMC)
                if(c!=null)
                    res.Nodes.Add(c.ToTree());
            return res;
        }

        public byte[] MatrixToBuff(Matrix m)
        {
            MemoryStream mem = new MemoryStream();
            mem.Write(BitConverter.GetBytes(m.M11), 0, 4);
            mem.Write(BitConverter.GetBytes(m.M12), 0, 4);
            mem.Write(BitConverter.GetBytes(m.M13), 0, 4);
            mem.Write(BitConverter.GetBytes(m.M14), 0, 4);

            mem.Write(BitConverter.GetBytes(m.M21), 0, 4);
            mem.Write(BitConverter.GetBytes(m.M22), 0, 4);
            mem.Write(BitConverter.GetBytes(m.M23), 0, 4);
            mem.Write(BitConverter.GetBytes(m.M24), 0, 4);

            mem.Write(BitConverter.GetBytes(m.M31), 0, 4);
            mem.Write(BitConverter.GetBytes(m.M32), 0, 4);
            mem.Write(BitConverter.GetBytes(m.M33), 0, 4);
            mem.Write(BitConverter.GetBytes(m.M34), 0, 4);

            mem.Write(BitConverter.GetBytes(m.M41), 0, 4);
            mem.Write(BitConverter.GetBytes(m.M42), 0, 4);
            mem.Write(BitConverter.GetBytes(m.M43), 0, 4);
            mem.Write(BitConverter.GetBytes(m.M44), 0, 4);
            return mem.ToArray();
        }

    }
}