//This class was generated by ME3Explorer
//Author: Warranty Voider
//URL: http://sourceforge.net/projects/me3explorer/
//URL: http://me3explorer.freeforums.org/
//URL: http://www.facebook.com/pages/Creating-new-end-for-Mass-Effect-3/145902408865659
using System;
using System.IO;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using ME3Explorer;
using ME3Explorer.Unreal;
using Microsoft.DirectX;
using Microsoft.DirectX.Direct3D;

namespace ME3Explorer.Unreal.Classes
{
    public class AnimSequence
    {
        #region Unreal Props

        //Byte Properties

        public int RotationCompressionFormat;
        public int KeyEncodingFormat;
        //Bool Properties

        public bool bIsAdditive = false;
        public bool bNoLoopingInterpolation = false;
        //Name Properties

        public int SequenceName;
        //Object Properties

        public int m_pBioAnimSetData;
        //Float Properties

        public float SequenceLength;
        public float RateScale;
        //Integer Properties

        public int NumFrames;
        //Array Properties

        public List<TrackOffsets> CompressedTrackOffsets;

        public struct TrackOffsets
        {
            public int TransOffset;
            public int TransNumKeys;
            public Vector3 Trans;
            public int RotOffset;
            public int RotNumKeys;
            public Vector4 Rot;
        }

        #endregion

        public int MyIndex;
        public PCCObject pcc;
        public byte[] data;
        public List<PropertyReader.Property> Props;
        public byte[] CompressedBlob;
        public int Unknown;

        public AnimSequence(PCCObject Pcc, int Index)
        {
            pcc = Pcc;
            MyIndex = Index;
            if (pcc.isExport(Index))
                data = pcc.Exports[Index].Data;            
            Props = PropertyReader.getPropList(pcc, data);
            BitConverter.IsLittleEndian = true;
            Unknown = BitConverter.ToInt32(data, 0);
            foreach (PropertyReader.Property p in Props)
                switch (pcc.getNameEntry(p.Name))
                {

                    case "RotationCompressionFormat":
                        RotationCompressionFormat = p.Value.IntValue;
                        break;
                    case "KeyEncodingFormat":
                        KeyEncodingFormat = p.Value.IntValue;
                        break;
                    case "bIsAdditive":
                        if (p.raw[p.raw.Length - 1] == 1)
                            bIsAdditive = true;
                        break;
                    case "bNoLoopingInterpolation":
                        if (p.raw[p.raw.Length - 1] == 1)
                            bNoLoopingInterpolation = true;
                        break;
                    case "SequenceName":
                        SequenceName = p.Value.IntValue;
                        break;
                    case "m_pBioAnimSetData":
                        m_pBioAnimSetData = p.Value.IntValue;
                        break;
                    case "SequenceLength":
                        SequenceLength = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "RateScale":
                        RateScale = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "NumFrames":
                        NumFrames = p.Value.IntValue;
                        break;
                    case "CompressedTrackOffsets":
                        ReadTrackOffsets(p.raw);
                        break;
                }
            ReadCompressedBlob();
        }

        public void ReadTrackOffsets(byte[] raw)
        {
            int count = GetArrayCount(raw);
            byte[] buff = GetArrayContent(raw);
            CompressedTrackOffsets = new List<TrackOffsets>();
            for (int i = 0; i < count / 4; i++)
            {
                TrackOffsets t = new TrackOffsets();
                t.TransOffset = BitConverter.ToInt32(buff, i * 16);
                t.RotNumKeys = BitConverter.ToInt32(buff, i * 16 + 4);
                t.RotOffset = BitConverter.ToInt32(buff, i * 16 + 8);
                t.RotNumKeys = BitConverter.ToInt32(buff, i * 16 + 12);
                CompressedTrackOffsets.Add(t);
            }
        }

        public int GetArrayCount(byte[] raw)
        {
            return BitConverter.ToInt32(raw, 24);
        }

        public byte[] GetArrayContent(byte[] raw)
        {
            byte[] buff = new byte[raw.Length - 28];
            for (int i = 0; i < raw.Length - 28; i++)
                buff[i] = raw[i + 28];
            return buff;
        }

        public void ReadCompressedBlob()
        {
            int pos = Props[Props.Count() - 1].offend;
            int size = BitConverter.ToInt32(data, pos);
            CompressedBlob = new byte[size];
            pos += 4;
            for (int i = 0; i < size; i++)
                CompressedBlob[i] = data[pos + i];
            for (int i = 0; i < CompressedTrackOffsets.Count; i++)
            {
                TrackOffsets t = CompressedTrackOffsets[i];
                t.Trans = ReadVector3(t.TransOffset);
                Vector3 CRot = ReadVector3(t.RotOffset);
                t.Rot = DecompressVector3(CRot);
                CompressedTrackOffsets[i] = t;
            }
        }

        public Vector4 DecompressVector3(Vector3 v)
        {
            Vector4 r = new Vector4(v.X, v.Y, v.Z, 0);
            float l = r.LengthSq();
            if (l == 0)
                r.W = -1;
            else if (l > 0 && l < 1.0f)
                r.W = (float)Math.Sqrt(1f - r.X * r.X - r.Y * r.Y - r.Z * r.Z) * -1f;
            return r;
        }

        public Vector4 ReadVector4(int pos)
        {
            Vector4 q = new Vector4();
            q.X = BitConverter.ToSingle(CompressedBlob, pos);
            q.Y = BitConverter.ToSingle(CompressedBlob, pos + 4) * -1f;
            q.Z = BitConverter.ToSingle(CompressedBlob, pos + 8);
            q.W = BitConverter.ToSingle(CompressedBlob, pos + 12);
            return q;
        }

        public Vector3 ReadVector3(int pos)
        {
            Vector3 q = new Vector3();
            q.X = BitConverter.ToSingle(CompressedBlob, pos);
            q.Y = BitConverter.ToSingle(CompressedBlob, pos + 4) * -1f;
            q.Z = BitConverter.ToSingle(CompressedBlob, pos + 8);
            return q;
        }

        public TreeNode ToTree()
        {
            TreeNode res = new TreeNode(pcc.Exports[MyIndex].ObjectName + "(#" + MyIndex + ")");
            res.Nodes.Add("RotationCompressionFormat : " + pcc.getNameEntry(RotationCompressionFormat));
            res.Nodes.Add("KeyEncodingFormat : " + pcc.getNameEntry(KeyEncodingFormat));
            res.Nodes.Add("bIsAdditive : " + bIsAdditive);
            res.Nodes.Add("bNoLoopingInterpolation : " + bNoLoopingInterpolation);
            res.Nodes.Add("SequenceName : " + pcc.getNameEntry(SequenceName));
            res.Nodes.Add("m_pBioAnimSetData : " + m_pBioAnimSetData);
            res.Nodes.Add("SequenceLength : " + SequenceLength);
            res.Nodes.Add("RateScale : " + RateScale);
            res.Nodes.Add("NumFrames : " + NumFrames);
            res.Nodes.Add(TracksToTree());
            return res;
        }

        public TreeNode TracksToTree()
        {
            TreeNode res = new TreeNode("CompressedTracks");
            for (int i = 0; i < CompressedTrackOffsets.Count; i++)
            {
                TrackOffsets t = CompressedTrackOffsets[i];
                string s = i + " :  Location( " + t.Trans.X + ", " + t.Trans.Y + ", " + t.Trans.Z + ") Trans.Numkeys(" + t.TransNumKeys + ") " ;
                s += "Rotation( " + t.Rot.X + ", " + t.Rot.Y + ", " + t.Rot.Z + ", " + t.Rot.W + ") Rot.Numkeys(" + t.RotNumKeys + ")";
                res.Nodes.Add(s);
            }
            return res;
        }

        public void ImportKeys(Vector3[] loc, Vector4[] rot, int time)
        {
            MemoryStream m = new MemoryStream();
            int pos = 0;
            int pos2 = 28;
            byte[] buff = new byte[0];
            foreach (PropertyReader.Property p in Props)
                if (pcc.getNameEntry(p.Name) == "CompressedTrackOffsets")
                    buff = p.raw;
            BitConverter.IsLittleEndian=true;
            for (int i = 0; i < CompressedTrackOffsets.Count; i++)
            {
                m.Write(BitConverter.GetBytes(loc[i].X), 0, 4);
                m.Write(BitConverter.GetBytes(loc[i].Y * -1f), 0, 4);
                m.Write(BitConverter.GetBytes(loc[i].Z), 0, 4);
                m.Write(BitConverter.GetBytes(rot[i].X), 0, 4);
                m.Write(BitConverter.GetBytes(rot[i].Y * -1f), 0, 4);
                m.Write(BitConverter.GetBytes(rot[i].Z), 0, 4);
                TrackOffsets t = CompressedTrackOffsets[i];
                t.Trans = loc[i];
                t.TransOffset = pos;
                t.TransNumKeys = 0;
                t.Rot = rot[i];
                t.RotOffset = pos + 12;
                t.RotNumKeys = time;
                CompressedTrackOffsets[i] = t;
                pos += 24;
                byte[] buff2 = BitConverter.GetBytes(t.TransOffset);
                for (int j = 0; j < 4; j++)
                    buff[pos2 + j] = buff2[j];
                buff2 = BitConverter.GetBytes(t.TransNumKeys);
                for (int j = 0; j < 4; j++)
                    buff[pos2 + j + 4] = buff2[j];
                buff2 = BitConverter.GetBytes(t.RotOffset);
                for (int j = 0; j < 4; j++)
                    buff[pos2 + j + 8] = buff2[j];
                buff2 = BitConverter.GetBytes(t.RotNumKeys);
                for (int j = 0; j < 4; j++)
                    buff[pos2 + j + 12] = buff2[j];
                pos2 += 16;
            }            
            foreach (PropertyReader.Property p in Props)
                if (pcc.getNameEntry(p.Name) == "CompressedTrackOffsets")
                    p.raw = buff;
            buff = BitConverter.GetBytes(time);
            foreach (PropertyReader.Property p in Props)
                if (pcc.getNameEntry(p.Name) == "NumFrames")
                    for (int j = 0; j < 4; j++)
                        p.raw[p.raw.Length + j - 4] = buff[j];
            CompressedBlob = m.ToArray();
        }

        public void SaveChanges()
        {
            MemoryStream m = new MemoryStream();
            m.Write(BitConverter.GetBytes((int)Unknown), 0, 4);
            foreach (PropertyReader.Property p in Props)
                m.Write(p.raw, 0, p.raw.Length);
            m.Write(BitConverter.GetBytes((int)CompressedBlob.Length), 0, 4);
            m.Write(CompressedBlob, 0, CompressedBlob.Length);
            pcc.Exports[MyIndex].Data = m.ToArray();
        }

    }
}