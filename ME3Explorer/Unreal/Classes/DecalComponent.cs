//This class was generated by ME3Explorer
//Author: Warranty Voider
//URL: http://sourceforge.net/projects/me3explorer/
//URL: http://me3explorer.freeforums.org/
//URL: http://www.facebook.com/pages/Creating-new-end-for-Mass-Effect-3/145902408865659
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using ME3Explorer.Unreal;
using Microsoft.DirectX;
using Microsoft.DirectX.Direct3D;

namespace ME3Explorer.Unreal.Classes
{
    public class DecalComponent
    {
        #region Unreal Props

        //Byte Properties

        public int FilterMode;
        //Bool Properties

        public bool bAcceptsDynamicDecals = false;
        public bool bFlipBackfaceDirection = false;
        public bool bProjectOnBackfaces = false;
        public bool bNoClip = false;
        public bool bAcceptsLights = false;
        public bool bAllowCullDistanceVolume = false;
        public bool bProjectOnBSP = false;
        public bool bProjectOnSkeletalMeshes = false;
        public bool bProjectOnTerrain = false;
        //Object Properties

        public int DecalMaterial;
        public int ReplacementPrimitive;
        //Float Properties

        public float Width;
        public float Height;
        public float FarPlane;
        public float TileX;
        public float TileY;
        public float NearPlane;
        public float DecalRotation;
        public float OffsetX;
        public float DepthBias;
        public float SlopeScaleDepthBias;
        public float OffsetY;
        public float MaxDrawDistance;
        public float CachedMaxDrawDistance;
        //Integer Properties

        public int SortOrder;
        public int TranslucencySortPriority;
        public int LocalTranslucencySortPriority;
        #endregion

        public int MyIndex;
        public PCCObject pcc;
        public byte[] data;
        public List<PropertyReader.Property> Props;

        public DecalComponent(PCCObject Pcc, int Index)
        {
            pcc = Pcc;
            MyIndex = Index;
            if (pcc.isExport(Index))
                data = pcc.Exports[Index].Data;
            Props = PropertyReader.getPropList(pcc, data);
            BitConverter.IsLittleEndian = true;
            foreach (PropertyReader.Property p in Props)
                switch (pcc.getNameEntry(p.Name))
                    #region
                {
                    case "FilterMode":
                        FilterMode = p.Value.IntValue;
                        break;
                    case "bAcceptsDynamicDecals":
                        if (p.raw[p.raw.Length - 1] == 1)
                            bAcceptsDynamicDecals = true;
                        break;
                    case "bFlipBackfaceDirection":
                        if (p.raw[p.raw.Length - 1] == 1)
                            bFlipBackfaceDirection = true;
                        break;
                    case "bProjectOnBackfaces":
                        if (p.raw[p.raw.Length - 1] == 1)
                            bProjectOnBackfaces = true;
                        break;
                    case "bNoClip":
                        if (p.raw[p.raw.Length - 1] == 1)
                            bNoClip = true;
                        break;
                    case "bAcceptsLights":
                        if (p.raw[p.raw.Length - 1] == 1)
                            bAcceptsLights = true;
                        break;
                    case "bAllowCullDistanceVolume":
                        if (p.raw[p.raw.Length - 1] == 1)
                            bAllowCullDistanceVolume = true;
                        break;
                    case "bProjectOnBSP":
                        if (p.raw[p.raw.Length - 1] == 1)
                            bProjectOnBSP = true;
                        break;
                    case "bProjectOnSkeletalMeshes":
                        if (p.raw[p.raw.Length - 1] == 1)
                            bProjectOnSkeletalMeshes = true;
                        break;
                    case "bProjectOnTerrain":
                        if (p.raw[p.raw.Length - 1] == 1)
                            bProjectOnTerrain = true;
                        break;
                    case "DecalMaterial":
                        DecalMaterial = p.Value.IntValue;
                        break;
                    case "ReplacementPrimitive":
                        ReplacementPrimitive = p.Value.IntValue;
                        break;
                    case "Width":
                        Width = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "Height":
                        Height = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "FarPlane":
                        FarPlane = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "TileX":
                        TileX = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "TileY":
                        TileY = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "NearPlane":
                        NearPlane = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "DecalRotation":
                        DecalRotation = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "OffsetX":
                        OffsetX = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "DepthBias":
                        DepthBias = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "SlopeScaleDepthBias":
                        SlopeScaleDepthBias = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "OffsetY":
                        OffsetY = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "MaxDrawDistance":
                        MaxDrawDistance = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "CachedMaxDrawDistance":
                        CachedMaxDrawDistance = BitConverter.ToSingle(p.raw, p.raw.Length - 4);
                        break;
                    case "SortOrder":
                        SortOrder = p.Value.IntValue;
                        break;
                    case "TranslucencySortPriority":
                        TranslucencySortPriority = p.Value.IntValue;
                        break;
                    case "LocalTranslucencySortPriority":
                        LocalTranslucencySortPriority = p.Value.IntValue;
                        break;
                }
                    #endregion                
        }

        public void Render(Device device, Matrix m)
        {

        }

        public void ProcessTreeClick(int[] path, bool AutoFocus, Matrix m)
        {

        }

        public void SetSelection(bool Selected)
        {

        }

        public TreeNode ToTree()
        {
            TreeNode res = new TreeNode(pcc.Exports[MyIndex].ObjectName + "(#" + MyIndex + ")");
            res.Nodes.Add("FilterMode : " + pcc.getNameEntry(FilterMode));
            res.Nodes.Add("bAcceptsDynamicDecals : " + bAcceptsDynamicDecals);
            res.Nodes.Add("bFlipBackfaceDirection : " + bFlipBackfaceDirection);
            res.Nodes.Add("bProjectOnBackfaces : " + bProjectOnBackfaces);
            res.Nodes.Add("bNoClip : " + bNoClip);

            res.Nodes.Add("bAcceptsLights : " + bAcceptsLights);
            res.Nodes.Add("bAllowCullDistanceVolume : " + bAllowCullDistanceVolume);
            res.Nodes.Add("bProjectOnBSP : " + bProjectOnBSP);
            res.Nodes.Add("bProjectOnSkeletalMeshes : " + bProjectOnSkeletalMeshes);
            res.Nodes.Add("bProjectOnTerrain : " + bProjectOnTerrain);
            
            res.Nodes.Add("DecalMaterial : " + DecalMaterial);
            res.Nodes.Add("ReplacementPrimitive : " + ReplacementPrimitive);
            res.Nodes.Add("Width : " + Width);
            res.Nodes.Add("Height : " + Height);            
            res.Nodes.Add("FarPlane : " + FarPlane);

            res.Nodes.Add("TileX : " + TileX);
            res.Nodes.Add("TileY : " + TileY);
            res.Nodes.Add("NearPlane : " + NearPlane);
            res.Nodes.Add("DecalRotation : " + DecalRotation);
            res.Nodes.Add("OffsetX : " + OffsetX);

            res.Nodes.Add("DepthBias : " + DepthBias);
            res.Nodes.Add("SlopeScaleDepthBias : " + SlopeScaleDepthBias);
            res.Nodes.Add("OffsetY : " + OffsetY);
            res.Nodes.Add("MaxDrawDistance : " + MaxDrawDistance);
            res.Nodes.Add("CachedMaxDrawDistance : " + CachedMaxDrawDistance);

            res.Nodes.Add("SortOrder : " + SortOrder);
            res.Nodes.Add("TranslucencySortPriority : " + TranslucencySortPriority);
            res.Nodes.Add("LocalTranslucencySortPriority : " + LocalTranslucencySortPriority);
            return res;
        }

    }
}